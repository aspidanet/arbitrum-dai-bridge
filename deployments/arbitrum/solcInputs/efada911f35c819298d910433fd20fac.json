{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !Address.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../access/Ownable.sol\";\nimport \"./TransparentUpgradeableProxy.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes memory data) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./UpgradeableProxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(admin_);\n    }\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _admin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\");\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\n        _upgradeTo(newImplementation);\n        Address.functionDelegateCall(newImplementation, data);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address adm) {\n        bytes32 slot = _ADMIN_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        bytes32 slot = _ADMIN_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/UpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Proxy.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n *\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n * {TransparentUpgradeableProxy}.\n */\ncontract UpgradeableProxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) public payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if(_data.length > 0) {\n            Address.functionDelegateCall(_logic, _data);\n        }\n    }\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal virtual {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\n\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/arbitrum/ArbSys.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.21 <0.7.0;\n\n/**\n * @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\n */\ninterface ArbSys {\n  /**\n   * @notice Get internal version number identifying an ArbOS build\n   * @return version number as int\n   */\n  function arbOSVersion() external pure returns (uint256);\n\n  function arbChainID() external view returns (uint256);\n\n  /**\n   * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\n   * @return block number as int\n   */\n  function arbBlockNumber() external view returns (uint256);\n\n  /**\n   * @notice Send given amount of Eth to dest from sender.\n   * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\n   * @param destination recipient address on L1\n   * @return unique identifier for this L2-to-L1 transaction.\n   */\n  function withdrawEth(address destination) external payable returns (uint256);\n\n  /**\n   * @notice Send a transaction to L1\n   * @param destination recipient address on L1\n   * @param calldataForL1 (optional) calldata for L1 contract call\n   * @return a unique identifier for this L2-to-L1 transaction.\n   */\n  function sendTxToL1(address destination, bytes calldata calldataForL1)\n    external\n    payable\n    returns (uint256);\n\n  /**\n   * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\n   * @param account target account\n   * @return the number of transactions issued by the given external account or the account sequence number of the given contract\n   */\n  function getTransactionCount(address account) external view returns (uint256);\n\n  /**\n   * @notice get the value of target L2 storage slot\n   * This function is only callable from address 0 to prevent contracts from being able to call it\n   * @param account target account\n   * @param index target index of storage slot\n   * @return stotage value for the given account at the given index\n   */\n  function getStorageAt(address account, uint256 index) external view returns (uint256);\n\n  /**\n   * @notice check if current call is coming from l1\n   * @return true if the caller of this was called directly from L1\n   */\n  function isTopLevelCall() external view returns (bool);\n\n  event EthWithdrawal(address indexed destAddr, uint256 amount);\n\n  event L2ToL1Transaction(\n    address caller,\n    address indexed destination,\n    uint256 indexed uniqueId,\n    uint256 indexed batchNumber,\n    uint256 indexInBatch,\n    uint256 arbBlockNum,\n    uint256 ethBlockNum,\n    uint256 timestamp,\n    uint256 callvalue,\n    bytes data\n  );\n}\n"
    },
    "contracts/arbitrum/IBridge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IBridge {\n  event MessageDelivered(\n    uint256 indexed messageIndex,\n    bytes32 indexed beforeInboxAcc,\n    address inbox,\n    uint8 kind,\n    address sender,\n    bytes32 messageDataHash\n  );\n\n  event BridgeCallTriggered(\n    address indexed outbox,\n    address indexed destAddr,\n    uint256 amount,\n    bytes data\n  );\n\n  event InboxToggle(address indexed inbox, bool enabled);\n\n  event OutboxToggle(address indexed outbox, bool enabled);\n\n  function deliverMessageToInbox(\n    uint8 kind,\n    address sender,\n    bytes32 messageDataHash\n  ) external payable returns (uint256);\n\n  function executeCall(\n    address destAddr,\n    uint256 amount,\n    bytes calldata data\n  ) external returns (bool success, bytes memory returnData);\n\n  // These are only callable by the admin\n  function setInbox(address inbox, bool enabled) external;\n\n  function setOutbox(address inbox, bool enabled) external;\n\n  // View functions\n\n  function activeOutbox() external view returns (address);\n\n  function allowedInboxes(address inbox) external view returns (bool);\n\n  function allowedOutboxes(address outbox) external view returns (bool);\n\n  function inboxAccs(uint256 index) external view returns (bytes32);\n\n  function messageCount() external view returns (uint256);\n}\n"
    },
    "contracts/arbitrum/IInbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./IMessageProvider.sol\";\n\ninterface IInbox is IMessageProvider {\n  function sendL2Message(bytes calldata messageData) external returns (uint256);\n\n  function sendUnsignedTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    uint256 nonce,\n    address destAddr,\n    uint256 amount,\n    bytes calldata data\n  ) external returns (uint256);\n\n  function sendContractTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    address destAddr,\n    uint256 amount,\n    bytes calldata data\n  ) external returns (uint256);\n\n  function sendL1FundedUnsignedTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    uint256 nonce,\n    address destAddr,\n    bytes calldata data\n  ) external payable returns (uint256);\n\n  function sendL1FundedContractTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    address destAddr,\n    bytes calldata data\n  ) external payable returns (uint256);\n\n  function createRetryableTicket(\n    address destAddr,\n    uint256 arbTxCallValue,\n    uint256 maxSubmissionCost,\n    address submissionRefundAddress,\n    address valueRefundAddress,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external payable returns (uint256);\n\n  function createRetryableTicketNoRefundAliasRewrite(\n    address destAddr,\n    uint256 arbTxCallValue,\n    uint256 maxSubmissionCost,\n    address submissionRefundAddress,\n    address valueRefundAddress,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external payable returns (uint256);\n\n  function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\n\n  function bridge() external view returns (address);\n\n  function pauseCreateRetryables() external;\n\n  function unpauseCreateRetryables() external;\n\n  function startRewriteAddress() external;\n\n  function stopRewriteAddress() external;\n}\n"
    },
    "contracts/arbitrum/IMessageProvider.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IMessageProvider {\n  event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\n\n  event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\n}\n"
    },
    "contracts/arbitrum/IOutbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IOutbox {\n  event OutboxEntryCreated(\n    uint256 indexed batchNum,\n    uint256 outboxEntryIndex,\n    bytes32 outputRoot,\n    uint256 numInBatch\n  );\n  event OutBoxTransactionExecuted(\n    address indexed destAddr,\n    address indexed l2Sender,\n    uint256 indexed outboxEntryIndex,\n    uint256 transactionIndex\n  );\n\n  function l2ToL1Sender() external view returns (address);\n\n  function l2ToL1Block() external view returns (uint256);\n\n  function l2ToL1EthBlock() external view returns (uint256);\n\n  function l2ToL1Timestamp() external view returns (uint256);\n\n  function l2ToL1BatchNum() external view returns (uint256);\n\n  function l2ToL1OutputId() external view returns (bytes32);\n\n  function processOutgoingMessages(bytes calldata sendsData, uint256[] calldata sendLengths)\n    external;\n\n  function outboxEntryExists(uint256 batchNum) external view returns (bool);\n}\n"
    },
    "contracts/l1/L1AspidaERC20Gateway.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts/proxy/Initializable.sol\";\nimport \"./L1CrossDomainEnabled.sol\";\nimport \"./L1ITokenGateway.sol\";\nimport \"../l2/L2ITokenGateway.sol\";\n\ninterface IAspidaERC20 {\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  ) external returns (bool success);\n}\n\ncontract L1AspidaERC20Gateway is Initializable, L1CrossDomainEnabled, L1ITokenGateway {\n  // --- Auth ---\n  mapping(address => uint256) public wards;\n\n  function rely(address usr) external auth {\n    wards[usr] = 1;\n    emit Rely(usr);\n  }\n\n  function deny(address usr) external auth {\n    wards[usr] = 0;\n    emit Deny(usr);\n  }\n\n  modifier auth() {\n    require(wards[msg.sender] == 1, \"L1AspidaERC20Gateway/not-authorized\");\n    _;\n  }\n\n  event Rely(address indexed usr);\n  event Deny(address indexed usr);\n\n  address public l1AspidaERC20;\n  address public l2AspidaERC20;\n  address public l1Escrow;\n  address public l1Router;\n  address public l2Counterpart;\n  uint256 public isOpen;\n\n  event Closed();\n\n  constructor(\n    address _l2Counterpart,\n    address _l1Router,\n    address _inbox,\n    address _l1AspidaERC20,\n    address _l2AspidaERC20,\n    address _l1Escrow\n  ) public {\n    initialize(_l2Counterpart, _l1Router, _inbox, _l1AspidaERC20, _l2AspidaERC20, _l1Escrow);\n  }\n\n  function initialize(\n    address _l2Counterpart,\n    address _l1Router,\n    address _inbox,\n    address _l1AspidaERC20,\n    address _l2AspidaERC20,\n    address _l1Escrow\n  ) public initializer {\n    isOpen = 1;\n    wards[msg.sender] = 1;\n    emit Rely(msg.sender);\n\n    l1AspidaERC20 = _l1AspidaERC20;\n    l2AspidaERC20 = _l2AspidaERC20;\n    l1Escrow = _l1Escrow;\n    l1Router = _l1Router;\n    l2Counterpart = _l2Counterpart;\n\n    __CrossDomainEnabled_init(_inbox);\n  }\n\n  function close() external auth {\n    isOpen = 0;\n\n    emit Closed();\n  }\n\n  function outboundTransfer(\n    address l1Token,\n    address to,\n    uint256 amount,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external payable override returns (bytes memory) {\n    // do not allow initiating new xchain messages if bridge is closed\n    require(isOpen == 1, \"L1AspidaERC20Gateway/closed\");\n    require(l1Token == l1AspidaERC20, \"L1AspidaERC20Gateway/token-not-AspidaERC20\");\n\n    // we use nested scope to avoid stack too deep errors\n    address from;\n    uint256 seqNum;\n    bytes memory extraData;\n    {\n      uint256 maxSubmissionCost;\n      (from, maxSubmissionCost, extraData) = parseOutboundData(data);\n      // require(extraData.length == 0, \"L1AspidaERC20Gateway/call-hook-data-not-allowed\");\n\n      IAspidaERC20(l1Token).transferFrom(from, l1Escrow, amount);\n\n      bytes memory outboundCalldata = getOutboundCalldata(l1Token, from, to, amount, extraData);\n      seqNum = sendTxToL2(\n        l2Counterpart,\n        from,\n        maxSubmissionCost,\n        maxGas,\n        gasPriceBid,\n        outboundCalldata\n      );\n    }\n\n    emit DepositInitiated(l1Token, from, to, seqNum, amount);\n\n    return abi.encode(seqNum);\n  }\n\n  function getOutboundCalldata(\n    address l1Token,\n    address from,\n    address to,\n    uint256 amount,\n    bytes memory data\n  ) public pure returns (bytes memory outboundCalldata) {\n    bytes memory emptyBytes = \"\";\n\n    outboundCalldata = abi.encodeWithSelector(\n      L2ITokenGateway.finalizeInboundTransfer.selector,\n      l1Token,\n      from,\n      to,\n      amount,\n      abi.encode(emptyBytes, data)\n    );\n\n    return outboundCalldata;\n  }\n\n  function finalizeInboundTransfer(\n    address l1Token,\n    address from,\n    address to,\n    uint256 amount,\n    bytes calldata data\n  ) external override onlyL2Counterpart(l2Counterpart) {\n    require(l1Token == l1AspidaERC20, \"L1AspidaERC20Gateway/token-not-AspidaERC20\");\n    (uint256 exitNum, ) = abi.decode(data, (uint256, bytes));\n\n    IAspidaERC20(l1Token).transferFrom(l1Escrow, to, amount);\n\n    emit WithdrawalFinalized(l1Token, from, to, exitNum, amount);\n  }\n\n  function parseOutboundData(bytes memory data)\n    internal\n    view\n    returns (\n      address from,\n      uint256 maxSubmissionCost,\n      bytes memory extraData\n    )\n  {\n    if (msg.sender == l1Router) {\n      // router encoded\n      (from, extraData) = abi.decode(data, (address, bytes));\n    } else {\n      from = msg.sender;\n      extraData = data;\n    }\n    // user encoded\n    (maxSubmissionCost, extraData) = abi.decode(extraData, (uint256, bytes));\n  }\n\n  function calculateL2TokenAddress(address l1Token) external view override returns (address) {\n    if (l1Token != l1AspidaERC20) {\n      return address(0);\n    }\n\n    return l2AspidaERC20;\n  }\n\n  function counterpartGateway() external view override returns (address) {\n    return l2Counterpart;\n  }\n}\n"
    },
    "contracts/l1/L1CrossDomainEnabled.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.11;\n\nimport \"../arbitrum/IBridge.sol\";\nimport \"../arbitrum/IInbox.sol\";\nimport \"../arbitrum/IOutbox.sol\";\n\nabstract contract L1CrossDomainEnabled {\n  IInbox public inbox;\n\n  event TxToL2(address indexed from, address indexed to, uint256 indexed seqNum, bytes data);\n\n  function __CrossDomainEnabled_init(address _inbox) internal {\n    inbox = IInbox(_inbox);\n  }\n\n  modifier onlyL2Counterpart(address l2Counterpart) {\n    // a message coming from the counterpart gateway was executed by the bridge\n    address bridge = inbox.bridge();\n    require(msg.sender == bridge, \"NOT_FROM_BRIDGE\");\n\n    // and the outbox reports that the L2 address of the sender is the counterpart gateway\n    address l2ToL1Sender = IOutbox(IBridge(bridge).activeOutbox()).l2ToL1Sender();\n    require(l2ToL1Sender == l2Counterpart, \"ONLY_COUNTERPART_GATEWAY\");\n    _;\n  }\n\n  function sendTxToL2(\n    address target,\n    address user,\n    uint256 maxSubmissionCost,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes memory data\n  ) internal returns (uint256) {\n    uint256 seqNum = inbox.createRetryableTicket{value: msg.value}(\n      target,\n      0, // we always assume that l2CallValue = 0\n      maxSubmissionCost,\n      user,\n      user,\n      maxGas,\n      gasPriceBid,\n      data\n    );\n    emit TxToL2(user, target, seqNum, data);\n    return seqNum;\n  }\n\n  function sendTxToL2NoAliasing(\n    address target,\n    address user,\n    uint256 l1CallValue,\n    uint256 maxSubmissionCost,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes memory data\n  ) internal returns (uint256) {\n    uint256 seqNum = inbox.createRetryableTicketNoRefundAliasRewrite{value: l1CallValue}(\n      target,\n      0, // we always assume that l2CallValue = 0\n      maxSubmissionCost,\n      user,\n      user,\n      maxGas,\n      gasPriceBid,\n      data\n    );\n    emit TxToL2(user, target, seqNum, data);\n    return seqNum;\n  }\n}\n"
    },
    "contracts/l1/L1DaiGateway.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.11;\n\nimport \"./L1ITokenGateway.sol\";\nimport \"../l2/L2ITokenGateway.sol\";\nimport \"./L1CrossDomainEnabled.sol\";\n\ninterface TokenLike {\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  ) external returns (bool success);\n}\n\ncontract L1DaiGateway is L1CrossDomainEnabled, L1ITokenGateway {\n  // --- Auth ---\n  mapping(address => uint256) public wards;\n\n  function rely(address usr) external auth {\n    wards[usr] = 1;\n    emit Rely(usr);\n  }\n\n  function deny(address usr) external auth {\n    wards[usr] = 0;\n    emit Deny(usr);\n  }\n\n  modifier auth() {\n    require(wards[msg.sender] == 1, \"L1DaiGateway/not-authorized\");\n    _;\n  }\n\n  event Rely(address indexed usr);\n  event Deny(address indexed usr);\n\n  address public immutable l1Dai;\n  address public immutable l2Dai;\n  address public immutable l1Escrow;\n  address public immutable l1Router;\n  address public immutable l2Counterpart;\n  uint256 public isOpen = 1;\n\n  event Closed();\n\n  constructor(\n    address _l2Counterpart,\n    address _l1Router,\n    address _inbox,\n    address _l1Dai,\n    address _l2Dai,\n    address _l1Escrow\n  ) public {\n    wards[msg.sender] = 1;\n    emit Rely(msg.sender);\n\n    l1Dai = _l1Dai;\n    l2Dai = _l2Dai;\n    l1Escrow = _l1Escrow;\n    l1Router = _l1Router;\n    l2Counterpart = _l2Counterpart;\n\n    __CrossDomainEnabled_init(_inbox);\n  }\n\n  function close() external auth {\n    isOpen = 0;\n\n    emit Closed();\n  }\n\n  function outboundTransfer(\n    address l1Token,\n    address to,\n    uint256 amount,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external payable override returns (bytes memory) {\n    // do not allow initiating new xchain messages if bridge is closed\n    require(isOpen == 1, \"L1DaiGateway/closed\");\n    require(l1Token == l1Dai, \"L1DaiGateway/token-not-dai\");\n\n    // we use nested scope to avoid stack too deep errors\n    address from;\n    uint256 seqNum;\n    bytes memory extraData;\n    {\n      uint256 maxSubmissionCost;\n      (from, maxSubmissionCost, extraData) = parseOutboundData(data);\n      require(extraData.length == 0, \"L1DaiGateway/call-hook-data-not-allowed\");\n\n      TokenLike(l1Token).transferFrom(from, l1Escrow, amount);\n\n      bytes memory outboundCalldata = getOutboundCalldata(l1Token, from, to, amount, extraData);\n      seqNum = sendTxToL2(\n        l2Counterpart,\n        from,\n        maxSubmissionCost,\n        maxGas,\n        gasPriceBid,\n        outboundCalldata\n      );\n    }\n\n    emit DepositInitiated(l1Token, from, to, seqNum, amount);\n\n    return abi.encode(seqNum);\n  }\n\n  function getOutboundCalldata(\n    address l1Token,\n    address from,\n    address to,\n    uint256 amount,\n    bytes memory data\n  ) public pure returns (bytes memory outboundCalldata) {\n    bytes memory emptyBytes = \"\";\n\n    outboundCalldata = abi.encodeWithSelector(\n      L2ITokenGateway.finalizeInboundTransfer.selector,\n      l1Token,\n      from,\n      to,\n      amount,\n      abi.encode(emptyBytes, data)\n    );\n\n    return outboundCalldata;\n  }\n\n  function finalizeInboundTransfer(\n    address l1Token,\n    address from,\n    address to,\n    uint256 amount,\n    bytes calldata data\n  ) external override onlyL2Counterpart(l2Counterpart) {\n    require(l1Token == l1Dai, \"L1DaiGateway/token-not-dai\");\n    (uint256 exitNum, ) = abi.decode(data, (uint256, bytes));\n\n    TokenLike(l1Token).transferFrom(l1Escrow, to, amount);\n\n    emit WithdrawalFinalized(l1Token, from, to, exitNum, amount);\n  }\n\n  function parseOutboundData(bytes memory data)\n    internal\n    view\n    returns (\n      address from,\n      uint256 maxSubmissionCost,\n      bytes memory extraData\n    )\n  {\n    if (msg.sender == l1Router) {\n      // router encoded\n      (from, extraData) = abi.decode(data, (address, bytes));\n    } else {\n      from = msg.sender;\n      extraData = data;\n    }\n    // user encoded\n    (maxSubmissionCost, extraData) = abi.decode(extraData, (uint256, bytes));\n  }\n\n  function calculateL2TokenAddress(address l1Token) external view override returns (address) {\n    if (l1Token != l1Dai) {\n      return address(0);\n    }\n\n    return l2Dai;\n  }\n\n  function counterpartGateway() external view override returns (address) {\n    return l2Counterpart;\n  }\n}\n"
    },
    "contracts/l1/L1Escrow.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts/proxy/Initializable.sol\";\n\ninterface ApproveLike {\n  function approve(address, uint256) external;\n}\n\n// Escrow funds on L1, manage approval rights\n\ncontract L1Escrow is Initializable {\n  // --- Auth ---\n  mapping(address => uint256) public wards;\n\n  function rely(address usr) external auth {\n    wards[usr] = 1;\n    emit Rely(usr);\n  }\n\n  function deny(address usr) external auth {\n    wards[usr] = 0;\n    emit Deny(usr);\n  }\n\n  modifier auth() {\n    require(wards[msg.sender] == 1, \"L1Escrow/not-authorized\");\n    _;\n  }\n\n  event Rely(address indexed usr);\n  event Deny(address indexed usr);\n\n  event Approve(address indexed token, address indexed spender, uint256 value);\n\n  constructor() public {\n    initialize();\n  }\n\n  function initialize() public initializer {\n    wards[msg.sender] = 1;\n    emit Rely(msg.sender);\n  }\n\n  function approve(\n    address token,\n    address spender,\n    uint256 value\n  ) external auth {\n    emit Approve(token, spender, value);\n\n    ApproveLike(token).approve(spender, value);\n  }\n}\n"
    },
    "contracts/l1/L1GovernanceRelay.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts/proxy/Initializable.sol\";\nimport \"./L1CrossDomainEnabled.sol\";\n\nimport \"../l2/L2GovernanceRelay.sol\";\n\n// Relay a message from L1 to L2GovernanceRelay\n// Sending L1->L2 message on arbitrum requires ETH balance. That's why this contract can receive ether.\n// Excessive ether can be reclaimed by governance by calling reclaim function.\n\ncontract L1GovernanceRelay is Initializable, L1CrossDomainEnabled {\n  // --- Auth ---\n  mapping(address => uint256) public wards;\n\n  function rely(address usr) external auth {\n    wards[usr] = 1;\n    emit Rely(usr);\n  }\n\n  function deny(address usr) external auth {\n    wards[usr] = 0;\n    emit Deny(usr);\n  }\n\n  modifier auth() {\n    require(wards[msg.sender] == 1, \"L1GovernanceRelay/not-authorized\");\n    _;\n  }\n\n  address public l2GovernanceRelay;\n\n  event Rely(address indexed usr);\n  event Deny(address indexed usr);\n\n  constructor(address _inbox, address _l2GovernanceRelay) public {\n    initialize(_inbox, _l2GovernanceRelay);\n  }\n\n  function initialize(address _inbox, address _l2GovernanceRelay) public initializer {\n    wards[msg.sender] = 1;\n    emit Rely(msg.sender);\n\n    l2GovernanceRelay = _l2GovernanceRelay;\n\n    __CrossDomainEnabled_init(_inbox);\n  }\n\n  // Allow contract to receive ether\n  receive() external payable {}\n\n  // Allow governance to reclaim stored ether\n  function reclaim(address receiver, uint256 amount) external auth {\n    (bool sent, ) = receiver.call{value: amount}(\"\");\n    require(sent, \"L1GovernanceRelay/failed-to-send-ether\");\n  }\n\n  // Forward a call to be repeated on L2\n  function relay(\n    address target,\n    bytes calldata targetData,\n    uint256 l1CallValue,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    uint256 maxSubmissionCost\n  ) external payable auth {\n    bytes memory data = abi.encodeWithSelector(\n      L2GovernanceRelay.relay.selector,\n      target,\n      targetData\n    );\n\n    sendTxToL2NoAliasing(\n      l2GovernanceRelay,\n      l2GovernanceRelay, // send any excess ether to the L2 counterpart\n      l1CallValue,\n      maxSubmissionCost,\n      maxGas,\n      gasPriceBid,\n      data\n    );\n  }\n}\n"
    },
    "contracts/l1/L1ITokenGateway.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.11;\n\n// differences between L1 and L2 version of this interface:\n// - payable modifier on outboundTransfer\n// - events\ninterface L1ITokenGateway {\n  event DepositInitiated(\n    address l1Token,\n    address indexed from,\n    address indexed to,\n    uint256 indexed sequenceNumber,\n    uint256 amount\n  );\n\n  event WithdrawalFinalized(\n    address l1Token,\n    address indexed from,\n    address indexed to,\n    uint256 indexed exitNum,\n    uint256 amount\n  );\n\n  function outboundTransfer(\n    address token,\n    address to,\n    uint256 amount,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external payable returns (bytes memory);\n\n  function finalizeInboundTransfer(\n    address token,\n    address from,\n    address to,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n\n  // if token is not supported this should return 0x0 address\n  function calculateL2TokenAddress(address l1Token) external view returns (address);\n\n  // used by router\n  function counterpartGateway() external view returns (address);\n}\n"
    },
    "contracts/l2/L2AspidaERC20Gateway.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts/proxy/Initializable.sol\";\n\nimport \"./L2CrossDomainEnabled.sol\";\nimport \"./L2ITokenGateway.sol\";\n\nimport \"../l1/L1ITokenGateway.sol\";\n\ninterface IAspidaERC20 {\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  ) external returns (bool success);\n\n  function minterMint(address usr, uint256 wad) external;\n\n  function minterBurn(uint256 wad) external;\n}\n\ninterface IOperator {\n  function executeStrategy(bytes memory data) external;\n}\n\ncontract L2AspidaERC20Gateway is Initializable, L2CrossDomainEnabled, L2ITokenGateway {\n  // --- Auth ---\n  mapping(address => uint256) public wards;\n\n  function rely(address usr) external auth {\n    wards[usr] = 1;\n    emit Rely(usr);\n  }\n\n  function deny(address usr) external auth {\n    wards[usr] = 0;\n    emit Deny(usr);\n  }\n\n  modifier auth() {\n    require(wards[msg.sender] == 1, \"L2AspidaERC20Gateway/not-authorized\");\n    _;\n  }\n\n  event Rely(address indexed usr);\n  event Deny(address indexed usr);\n\n  address public l1AspidaERC20;\n  address public l2AspidaERC20;\n  address public l1Counterpart;\n  address public l2Router;\n  uint256 public isOpen;\n\n  event Closed();\n\n  constructor(\n    address _l1Counterpart,\n    address _l2Router,\n    address _l1AspidaERC20,\n    address _l2AspidaERC20\n  ) public {\n    initialize(_l1Counterpart, _l2Router, _l1AspidaERC20, _l2AspidaERC20);\n  }\n\n  function initialize(\n    address _l1Counterpart,\n    address _l2Router,\n    address _l1AspidaERC20,\n    address _l2AspidaERC20\n  ) public initializer {\n    isOpen = 1;\n    wards[msg.sender] = 1;\n    emit Rely(msg.sender);\n\n    l1AspidaERC20 = _l1AspidaERC20;\n    l2AspidaERC20 = _l2AspidaERC20;\n    l1Counterpart = _l1Counterpart;\n    l2Router = _l2Router;\n  }\n\n  function close() external auth {\n    isOpen = 0;\n\n    emit Closed();\n  }\n\n  function outboundTransfer(\n    address l1Token,\n    address to,\n    uint256 amount,\n    bytes calldata data\n  ) external returns (bytes memory) {\n    return outboundTransfer(l1Token, to, amount, 0, 0, data);\n  }\n\n  function outboundTransfer(\n    address l1Token,\n    address to,\n    uint256 amount,\n    uint256, // maxGas\n    uint256, // gasPriceBid\n    bytes calldata data\n  ) public override returns (bytes memory res) {\n    require(isOpen == 1, \"L2AspidaERC20Gateway/closed\");\n    require(l1Token == l1AspidaERC20, \"L2AspidaERC20Gateway/token-not-AspidaERC20\");\n\n    (address from, bytes memory extraData) = parseOutboundData(data);\n    require(extraData.length == 0, \"L2AspidaERC20Gateway/call-hook-data-not-allowed\");\n\n    IAspidaERC20(l2AspidaERC20).transferFrom(from, address(this), amount);\n    IAspidaERC20(l2AspidaERC20).minterBurn(amount);\n\n    uint256 id = sendTxToL1(\n      from,\n      l1Counterpart,\n      getOutboundCalldata(l1Token, from, to, amount, extraData)\n    );\n\n    // we don't need to track exitNums (b/c we have no fast exits) so we always use 0\n    emit WithdrawalInitiated(l1Token, from, to, id, 0, amount);\n\n    return abi.encode(id);\n  }\n\n  function getOutboundCalldata(\n    address token,\n    address from,\n    address to,\n    uint256 amount,\n    bytes memory data\n  ) public pure returns (bytes memory outboundCalldata) {\n    outboundCalldata = abi.encodeWithSelector(\n      L1ITokenGateway.finalizeInboundTransfer.selector,\n      token,\n      from,\n      to,\n      amount,\n      abi.encode(0, data) // we don't need to track exitNums (b/c we have no fast exits) so we always use 0\n    );\n\n    return outboundCalldata;\n  }\n\n  function finalizeInboundTransfer(\n    address l1Token,\n    address from,\n    address to,\n    uint256 amount,\n    bytes calldata data\n  ) external override onlyL1Counterpart(l1Counterpart) {\n    require(l1Token == l1AspidaERC20, \"L2AspidaERC20Gateway/token-not-AspidaERC20\");\n\n    IAspidaERC20(l2AspidaERC20).minterMint(to, amount);\n\n    emit DepositFinalized(l1Token, from, to, amount);\n\n    (, bytes memory actualData) = abi.decode(data, (bytes, bytes));\n    if (actualData.length > 32) {\n      IOperator(to).executeStrategy(actualData);\n    }\n  }\n\n  function calculateL2TokenAddress(address l1Token) external view override returns (address) {\n    if (l1Token != l1AspidaERC20) {\n      return address(0);\n    }\n\n    return l2AspidaERC20;\n  }\n\n  function parseOutboundData(bytes memory data)\n    internal\n    view\n    returns (address from, bytes memory extraData)\n  {\n    if (msg.sender == l2Router) {\n      (from, extraData) = abi.decode(data, (address, bytes));\n    } else {\n      from = msg.sender;\n      extraData = data;\n    }\n  }\n\n  function counterpartGateway() external view override returns (address) {\n    return l1Counterpart;\n  }\n}\n"
    },
    "contracts/l2/L2CrossDomainEnabled.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.11;\n\nimport \"../arbitrum/ArbSys.sol\";\n\nabstract contract L2CrossDomainEnabled {\n  event TxToL1(address indexed from, address indexed to, uint256 indexed id, bytes data);\n\n  function sendTxToL1(\n    address user,\n    address to,\n    bytes memory data\n  ) internal returns (uint256) {\n    // note: this method doesn't support sending ether to L1 together with a call\n    uint256 id = ArbSys(address(100)).sendTxToL1(to, data);\n\n    emit TxToL1(user, to, id, data);\n\n    return id;\n  }\n\n  modifier onlyL1Counterpart(address l1Counterpart) {\n    require(msg.sender == applyL1ToL2Alias(l1Counterpart), \"ONLY_COUNTERPART_GATEWAY\");\n    _;\n  }\n\n  uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n  // l1 addresses are transformed durng l1->l2 calls\n  function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n    l2Address = address(uint160(l1Address) + offset);\n  }\n}\n"
    },
    "contracts/l2/L2DaiGateway.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.11;\n\nimport \"./L2ITokenGateway.sol\";\nimport \"../l1/L1ITokenGateway.sol\";\nimport \"./L2CrossDomainEnabled.sol\";\n\ninterface Mintable {\n  function mint(address usr, uint256 wad) external;\n\n  function burn(address usr, uint256 wad) external;\n}\n\ncontract L2DaiGateway is L2CrossDomainEnabled, L2ITokenGateway {\n  // --- Auth ---\n  mapping(address => uint256) public wards;\n\n  function rely(address usr) external auth {\n    wards[usr] = 1;\n    emit Rely(usr);\n  }\n\n  function deny(address usr) external auth {\n    wards[usr] = 0;\n    emit Deny(usr);\n  }\n\n  modifier auth() {\n    require(wards[msg.sender] == 1, \"L2DaiGateway/not-authorized\");\n    _;\n  }\n\n  event Rely(address indexed usr);\n  event Deny(address indexed usr);\n\n  address public immutable l1Dai;\n  address public immutable l2Dai;\n  address public immutable l1Counterpart;\n  address public immutable l2Router;\n  uint256 public isOpen = 1;\n\n  event Closed();\n\n  constructor(\n    address _l1Counterpart,\n    address _l2Router,\n    address _l1Dai,\n    address _l2Dai\n  ) public {\n    wards[msg.sender] = 1;\n    emit Rely(msg.sender);\n\n    l1Dai = _l1Dai;\n    l2Dai = _l2Dai;\n    l1Counterpart = _l1Counterpart;\n    l2Router = _l2Router;\n  }\n\n  function close() external auth {\n    isOpen = 0;\n\n    emit Closed();\n  }\n\n  function outboundTransfer(\n    address l1Token,\n    address to,\n    uint256 amount,\n    bytes calldata data\n  ) external returns (bytes memory) {\n    return outboundTransfer(l1Token, to, amount, 0, 0, data);\n  }\n\n  function outboundTransfer(\n    address l1Token,\n    address to,\n    uint256 amount,\n    uint256, // maxGas\n    uint256, // gasPriceBid\n    bytes calldata data\n  ) public override returns (bytes memory res) {\n    require(isOpen == 1, \"L2DaiGateway/closed\");\n    require(l1Token == l1Dai, \"L2DaiGateway/token-not-dai\");\n\n    (address from, bytes memory extraData) = parseOutboundData(data);\n    require(extraData.length == 0, \"L2DaiGateway/call-hook-data-not-allowed\");\n\n    Mintable(l2Dai).burn(from, amount);\n\n    uint256 id = sendTxToL1(\n      from,\n      l1Counterpart,\n      getOutboundCalldata(l1Token, from, to, amount, extraData)\n    );\n\n    // we don't need to track exitNums (b/c we have no fast exits) so we always use 0\n    emit WithdrawalInitiated(l1Token, from, to, id, 0, amount);\n\n    return abi.encode(id);\n  }\n\n  function getOutboundCalldata(\n    address token,\n    address from,\n    address to,\n    uint256 amount,\n    bytes memory data\n  ) public pure returns (bytes memory outboundCalldata) {\n    outboundCalldata = abi.encodeWithSelector(\n      L1ITokenGateway.finalizeInboundTransfer.selector,\n      token,\n      from,\n      to,\n      amount,\n      abi.encode(0, data) // we don't need to track exitNums (b/c we have no fast exits) so we always use 0\n    );\n\n    return outboundCalldata;\n  }\n\n  function finalizeInboundTransfer(\n    address l1Token,\n    address from,\n    address to,\n    uint256 amount,\n    bytes calldata // data -- unsused\n  ) external override onlyL1Counterpart(l1Counterpart) {\n    require(l1Token == l1Dai, \"L2DaiGateway/token-not-dai\");\n\n    Mintable(l2Dai).mint(to, amount);\n\n    emit DepositFinalized(l1Token, from, to, amount);\n  }\n\n  function calculateL2TokenAddress(address l1Token) external view override returns (address) {\n    if (l1Token != l1Dai) {\n      return address(0);\n    }\n\n    return l2Dai;\n  }\n\n  function parseOutboundData(bytes memory data)\n    internal\n    view\n    returns (address from, bytes memory extraData)\n  {\n    if (msg.sender == l2Router) {\n      (from, extraData) = abi.decode(data, (address, bytes));\n    } else {\n      from = msg.sender;\n      extraData = data;\n    }\n  }\n\n  function counterpartGateway() external view override returns (address) {\n    return l1Counterpart;\n  }\n}\n"
    },
    "contracts/l2/L2GovernanceRelay.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts/proxy/Initializable.sol\";\nimport \"./L2CrossDomainEnabled.sol\";\n\n// Receive xchain message from L1 counterpart and execute given spell\n\ncontract L2GovernanceRelay is Initializable, L2CrossDomainEnabled {\n  address public l1GovernanceRelay;\n\n  constructor(address _l1GovernanceRelay) public {\n    initialize(_l1GovernanceRelay);\n  }\n\n  function initialize(address _l1GovernanceRelay) public initializer {\n    l1GovernanceRelay = _l1GovernanceRelay;\n  }\n\n  // Allow contract to receive ether\n  receive() external payable {}\n\n  function relay(address target, bytes calldata targetData)\n    external\n    onlyL1Counterpart(l1GovernanceRelay)\n  {\n    (bool ok, ) = target.delegatecall(targetData);\n    // note: even if a retryable call fails, it can be retried\n    require(ok, \"L2GovernanceRelay/delegatecall-error\");\n  }\n}\n"
    },
    "contracts/l2/L2ITokenGateway.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.11;\n\ninterface L2ITokenGateway {\n  event DepositFinalized(\n    address indexed l1Token,\n    address indexed from,\n    address indexed to,\n    uint256 amount\n  );\n\n  event WithdrawalInitiated(\n    address l1Token,\n    address indexed from,\n    address indexed to,\n    uint256 indexed l2ToL1Id,\n    uint256 exitNum,\n    uint256 amount\n  );\n\n  function outboundTransfer(\n    address token,\n    address to,\n    uint256 amount,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external returns (bytes memory);\n\n  function finalizeInboundTransfer(\n    address token,\n    address from,\n    address to,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n\n  // if token is not supported this should return 0x0 address\n  function calculateL2TokenAddress(address l1Token) external view returns (address);\n\n  // used by router\n  function counterpartGateway() external view returns (address);\n}\n"
    },
    "contracts/library/ProxyImport.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts/proxy/ProxyAdmin.sol\";\n\ncontract ProxyImport is ProxyAdmin {}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}